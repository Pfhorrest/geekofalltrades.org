<?php $title = "Architecting Governware &ndash; by Forrest Cameranesi" ?>
<?php require $_SERVER['DOCUMENT_ROOT'] . "/includes/header-dynamic.php" ?>
				
				<section>

					<h2>Architecting Governware</h2>
				
					<p class="description">An analogy between software and government, 2011.</p>

					<p>There are two ostensibly competing approaches to architecting software: designing the front-end first and then programming whatever necessary to produce that front-end; or programming the back-end first and allowing whatever interface design flows naturally from that back-end to surface.</p>
					<p>Software architected solely by designers often looks nice and is "easy to use" in one sense: approachable to the general user and not just the technological elite. But such software is just as frequently horribly inefficient, inconsistent, and buggy, making it in other senses very difficult to use outside of its prime use cases.</p>
					<p>Software architected solely by programmers, on the other hand, may be a marvel of ingenious consistency and efficiency and may even be provably mathematically correct. But it will often have an interface apparently based in the philosophy that if you can't figure this out on your own, you don't <em>deserve</em> to use such software.</p>
					<p>The technological elite often prefer software architected more by programmers than by designers, because they have the ability to make precision demands of it and have it do exactly what they want, and it stays out of their way otherwise; whereas designer-architected software tends to slow them down and keep them from doing what they are trying to do.</p>
					<p>General users, on the other hand, often prefer software architected more by designers than by programmers, because for whatever faults it has, most of them can usually at least go about using it somewhat and get some kind of functionality out of it, instead of having to beg or pay the technological elite to get them what they need.</p>
					<p>But the best software is undoubtedly architected by teams with both design insights and programming insights, collaborating to create a product which consistently and efficiently offers the desired functionality in an appealing, intuitive, discoverable manner, approachable to general users without holding back the more adept, and even making the latter more productive in their work.</p>
					<p>Socialists are like software designers: they have all the right ends in mind, they want to make the world a place that is comfortable and easy to make a living in for anyone, not just an elite few; but they often have no regards for the correctness of the means used to reach these ends. For the sake of justice, equality, and the general welfare, they will often disregard or downplay the possibility of such means to lead to a lower overall welfare for the whole of society (inefficiency), of dissolving the principle of equality before the law (inconsistency), or of commiting injustices themselves in the pursuit of the "greater good" (incorrectness).</p>
					<p>Libertarians, on the other hand, are like software programmers: they place tremendous emphasis on never allowing the smallest violation of rights to fly (correctness), on treating everyone as exactly equal before the law (consistency), and within those restraints, on generating the greatest output for the least cost (efficiency). However, they often stop there and assume that the best outcome will just naturally follow from this with no further effort necessary; and that if people can't make themselves a comfortable, easy living within such a framework, then they obviously must be doing something wrong and not deserve such wealth anyway.</p>
					<p>The wealthy social elite often prefer a government adhereing to libertarian principles more than socialist ones, because they already have the means of getting what they need from it, and it stays out of their way the rest of the time; whereas a socialist government will often tend to place burdens on them they otherwise would not have, and impede their freedom of action.</p>
					<p>The general populace, on the other hand, often prefer a government adhering to socialist principles more than libertarian ones, because for whatever faults a socialist government may have, they can at least get some direct benefit out of it, instead of having to beg or pay the wealthy elites to get them what they need.</p>
					<p>But the best government needs to be grounded in principles both libertarian and socialist: aiming first to most effectively safeguard everyone's rights equally; but then, without compromising that mission, to go further and establish a safety net from the inequities and injustice that are not caused by man alone, to protect those who were thrust into or simply stumbled into unfortunate circumstances from bearing the burden of that bad luck by themselves, so that everyone has a truly equal opportunity to make the best out of their own lives.</p>
					<p>How to accomplish such ends without compromising our means may be a difficult question, but it is one that cannot be answered if we do not start asking it; and we will not start asking it so long as we believe that it is unanswerable, that <em>doing good things</em> and <em>doing things right</em>, that good ends and right means, are mutually exclusive. We cannot allow doing good things, reaching for good ends, to justify using the wrong means; but neither can we allow doing things right, using only the right means, to justify a callousness towards bad ends which may nevertheless occur. We must strive to <em>do good things right</em>; we must fight to achieve good ends, but only by the right means.</p>

					<p>Furthermore, there is a second-order issue at hand: even once we have accepted the goal (or end) of <em>doing good things right</em>, there is the question of the method (or means) of changing what we have in place now to such a system.</p>
					<p>In software, there are three approaches to this problem. One is to keep patching the current system as it is without fundamentally changing the core of the program, simply fixing one bug after another as they crop up and hoping that this eventually fixes all the problems. Another approach is to abandon the current line of the product entirely and set to work building a complete replacement from the ground up, and let the users simply do without in the meanwhile. The third approach is to keep supporting the current line while concurrently developing replacement modules from the ground up, phasing out the buggy old modules for the shiny new ones as they are completed, eventually ending up with a completely refactored product with no interruption of service over the course of it's development: in the end you have the same product as far as the end-user is concerned, no major disturbance in their user experience, only it's less buggy, more efficient and more consistent, because on the inside it's been completely rebuilt.</p>
					<p>These same three approaches can be applied to changes in government. The first and third approaches we might call in political terms "conservative", in that they conserve what currently works about the system and don't simply throw it all out for something new and hopefully (but not necessarily) better. The second and third approaches we might call "progressive", in that they do not cling the the dysfunctional cruft of the current system and just try to smooth it over with layer after layer of fixes, but instead dig out the roots of the problem and rebuild something better in their place. The first approach, which is conservative and not progressive, we may call "reactionary", as it strives to keep what's already there and only change as absolutely necessary to continue functioning. The second approach, which is progressive and not conversative, we may call "radical", as it throws out everything that's already there and hopes for the best in what replaces it. The third approach, which is conservatively progressive, or progressively conservative, refactoring the internal structure while presenting an uninterrupted external function, is clearly the superior option, whether we're discussing software or government.</p>
					<p>Note again the important distinction between these approaches to the methods of change, and positions on what the goal of that change is. People who defend the overall status quo and simply want patches made to fix their least favorite bugs are not only conservatives but reactionaries, be they on either the left or the right. Likewise, people who want to throw out everything that we have going now and replace it immediately with their utopian system are not only progressives but radicals, be they on either the left or the right. But the dichotomy between reactionaries and radicals is a false one: there remains room still for a conservatively progressive approach, which is no more a contradiction in terms than libertarian socialism.</p>

					<p>Combined, the first-order issues of what ends the government needs to meet and what means to which it needs to adhere, and the second-order issue by what (meta)-means to achieve those (meta)-ends, produce a mix of political stances both familiar and strange. On the one hand, we can say that there are still social ends going unmet and that changes need to be made to address them: that position would be socialist progressivism, an entirely familiar combination. On the other hand, we can say at the same time that there are individual rights which must be protected and cannot be further eroded in pursuit of any ends: that position would be libertarian conservativism, another familiar combination. But, on the same hand as that, we can say further that there are many individual rights which have already been eroded too far, and that changes need to be made to restore them: which would be libertarian progressivism, a strange term in today's political dialogue. And back on the first hand again, we can equally say that there are existing social programs in place which cannot just be discarded, even if the means of supporting them need to change: which would be socialist conservativism, another strange term in today's political dialogue.</p>
					
					<p>The important lesson to take home is that none of these terms, the familiar or the strange, are contradictions, either within themselves or between each other. It is possible to be socialist without being illiberal, to be libertarian without being antisocial, to be progressive without being radical, to be conservative without being reactionary; in short, to be a conservatively progressive libertarian socialist. How exactly to manage that is a delicate and difficult practical problem, but one which we cannot hope to solve if we declare it impossible from the outset.</p>

				</section>
	
<?php require $_SERVER['DOCUMENT_ROOT'] . "/includes/footer-global.php" ?>
